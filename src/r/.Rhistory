)
grid.arrange(
ggplot(df.orig, aes(x = month, y = value)) + geom_point() + geom_line()
, ggplot(df.clean, aes(x = month, y = value)) + geom_point() + geom_line()
)
ggplot() +
geom_line(data = df.orig, aes(x = month, y = value), color = "red") +
geom_point(data = df.orig, aes(x = month, y = value), color = "red") +
geom_line(data = df.clean, aes(x = month, y = value), color = "blue") +
geom_point(data = df.clean, aes(x = month, y = value), color = "blue") +
xlab('Month') +
ylab('KWH Consumptions')
plot(stl(ts.clean, "per"))
plot(stl(ts.clean, s.window = 12, t.window = 50, t.jump = 1))
tb <- as_tibble(df)
tb
tb =  select(filter(tb_all, Building_Meter == account), 'Month', 'Imputed_KWH')
ts_anomalized <- tb %>%
time_decompose(Imputed_KWH, method = "STL", merge = TRUE) %>%
ts_anomalized <- tb %>%
time_decompose(Imputed_KWH, method = "STL", merge = TRUE)
ts_anomalized
ts.stl <- stl(ts.clean, s.window = 12, t.window = 51, t.jump = 1)
ts.stl
head(ts.stl)
ts.stl$time.series
head(ts.stl$time.series)
head(ts_anomalized)
?stl
ts.stl <- stl(ts.clean, s.window = 13, t.window = 51, t.jump = 1)
head(ts.stl$time.series)
head(ts_anomalized)
mstl(ts.clean)
ts.stl <- mstl(ts.clean)
seasadj(ts.stl)
plot(seasadj(ts.stl))
plot(seasonal(ts.stl))
plot(trendcycle(ts.stl))
ts.stl <- mstl(ts.orig)
plot(seasonal(ts.stl))
plot(trendcycle(ts.stl))
ts.stl %>% autoplot()
# no missing value
account = '102.0 - BLD 02_8107087'
tb =  select(filter(tb_all, Building_Meter == account), 'Month', 'Imputed_KWH')
ggplot(tb, aes(x = Month, y = Imputed_KWH)) + geom_point() + geom_line()
# no missing value
account = '102.0 - BLD 02_8107087'
tb =  select(filter(tb_all, Building_Meter == account), 'Month', 'Imputed_KWH')
ggplot(tb, aes(x = Month, y = Imputed_KWH)) + geom_point() + geom_line()
filter(accounts, na_perc > 0.1)
# lots of missing values
account = '1.0 - BLD 01_7836716'
tb =  select(filter(tb_all, Building_Meter == account), 'Month', 'Imputed_KWH')
ggplot(tb, aes(x = Month, y = Imputed_KWH)) + geom_point() + geom_line()
# Forecast package, tsclean for imputation & outlier detection
# convert the tibble to time series object
tb <- tb[order(tb$Month), ]
ts.orig <- ts(tb$Imputed_KWH, start = c(year(min(tb$Month)), month(min(tb$Month))),, frequency = 12)
ts.clean <- tsclean(ts.orig)
ts.plot(ts.orig, ts.clean, gpars = list(col = c("red", "blue")))
# define a function to convert ts to dataframe
ts_to_df <- function(ts) {
data.frame(month = as.Date(as.yearmon(time(ts))), value = as.matrix(ts))
}
df.orig <- ts_to_df(ts.orig)
df.clean <- ts_to_df(ts.clean)
df <- cbind(df.orig, df.clean[, 2])
colnames(df) <- c('month', 'value.orig', 'value.forecasted')
df <- mutate(df, value.diff = value.forecasted - value.orig)
filter(df, value.diff != 0)
# better visualization to compare the observed and cleaned
ggplot() +
geom_line(data = df.orig, aes(x = month, y = value), color = "red") +
geom_point(data = df.orig, aes(x = month, y = value), color = "red") +
geom_line(data = df.clean, aes(x = month, y = value), color = "blue") +
geom_point(data = df.clean, aes(x = month, y = value), color = "blue") +
xlab('Month') +
ylab('KWH Consumptions')
grid.arrange(
ggplot(df.orig, aes(x = month, y = value)) + geom_point() + geom_line()
, ggplot(df.clean, aes(x = month, y = value)) + geom_point() + geom_line()
)
# better visualization to compare the observed and cleaned
ggplot() +
geom_line(data = df.orig, aes(x = month, y = value), color = "red") +
geom_point(data = df.orig, aes(x = month, y = value), color = "red") +
geom_line(data = df.clean, aes(x = month, y = value), color = "blue") +
geom_point(data = df.clean, aes(x = month, y = value), color = "blue") +
xlab('Month') +
ylab('KWH Consumptions')
grid.arrange(
ggplot(df.orig, aes(x = month, y = value)) + geom_point() + geom_line()
, ggplot(df.clean, aes(x = month, y = value)) + geom_point() + geom_line()
)
plot(stl(ts.clean, "per"))
ts.stl <- mstl(ts.orig)
ts.stl <- mstl(ts.orig)
ts.stl %>% autoplot()
ts.orig %>% autoplot()
ts.stl %>% autoplot()
ts.stl <- mstl(ts.clean)
ts.stl %>% autoplot()
ts.orig %>% autoplot()
ts.stl <- mstl(ts.orig)
ts.stl %>% autoplot()
ts.stl <- mstl(ts.clean)
ts.stl %>% autoplot()
ts.stl1 <- mstl(ts.orig)
ts.stl1 %>% autoplot()
ts.stl2 <- mstl(ts.clean)
ts.stl2 %>% autoplot()
ts.orig %>% autoplot()
ts.clean %>% autoplot()
# no missing value
account = '102.0 - BLD 02_8107087'
tb =  select(filter(tb_all, Building_Meter == account), 'Month', 'Imputed_KWH')
ggplot(tb, aes(x = Month, y = Imputed_KWH)) + geom_point() + geom_line()
# Forecast package, tsclean for imputation & outlier detection
# convert the tibble to time series object
tb <- tb[order(tb$Month), ]
ts.orig <- ts(tb$Imputed_KWH, start = c(year(min(tb$Month)), month(min(tb$Month))),, frequency = 12)
ts.clean <- tsclean(ts.orig)
ts.plot(ts.orig, ts.clean, gpars = list(col = c("red", "blue")))
# define a function to convert ts to dataframe
ts_to_df <- function(ts) {
data.frame(month = as.Date(as.yearmon(time(ts))), value = as.matrix(ts))
}
df.orig <- ts_to_df(ts.orig)
df.clean <- ts_to_df(ts.clean)
df <- cbind(df.orig, df.clean[, 2])
colnames(df) <- c('month', 'value.orig', 'value.forecasted')
df <- mutate(df, value.diff = value.forecasted - value.orig)
filter(df, value.diff != 0)
# better visualization to compare the observed and cleaned
ggplot() +
geom_line(data = df.orig, aes(x = month, y = value), color = "red") +
geom_point(data = df.orig, aes(x = month, y = value), color = "red") +
geom_line(data = df.clean, aes(x = month, y = value), color = "blue") +
geom_point(data = df.clean, aes(x = month, y = value), color = "blue") +
xlab('Month') +
ylab('KWH Consumptions')
grid.arrange(
ggplot(df.orig, aes(x = month, y = value)) + geom_point() + geom_line()
, ggplot(df.clean, aes(x = month, y = value)) + geom_point() + geom_line()
)
tb =  select(filter(tb_all, Building_Meter == account), 'Month', 'Imputed_KWH')
ts_anomalized <- tb %>%
time_decompose(Imputed_KWH, method = "STL", merge = TRUE)
ts_anomalized
ts.orig %>% autoplot()
ts.clean %>% autoplot()
ts.clean %>% autoplot()
ts.orig %>% autoplot()
ts.clean %>% autoplot()
ts.stl1 <- mstl(ts.orig)
ts.stl1 %>% autoplot()
ts_anomalized %>% plot_anomaly_decomposition(alpha_dot = 0.5) +
ggtitle("Observed & Residuals")
ts_anomalized <- ts %>%
time_decompose(Imputed_KWH, method = "STL", merge = TRUE) %>%
anomalize(remainder, method = 'iqr', alpha = 0.05) %>%
time_recompose()
tb =  select(filter(tb_all, Building_Meter == account), 'Month', 'Imputed_KWH')
ts_anomalized <- tb %>%
time_decompose(Imputed_KWH, method = "STL", merge = TRUE) %>%
anomalize(remainder, method = 'iqr', alpha = 0.05) %>%
time_recompose()
ts_anomalized %>% plot_anomaly_decomposition(alpha_dot = 0.5) +
ggtitle("Observed & Residuals")
min(tb$Imputed_KWH)
match(min(tb$Imputed_KWH), ts.orig)
ts.orig
ts_anomalized %>% plot_anomaly_decomposition(alpha_dot = 0.5) +
ggtitle("Observed & Residuals")
ts.orig
library(tidyverse)
library(tibbletime)
library(anomalize)
library(lubridate)
library(forecast)
library(zoo)
library(gridExtra)
setwd("/Users/feiwang/Desktop/capstone/anomalyDetectors/src/r")
tb_all = read_csv("../../output/NYCHA_TS.csv")
tb_all = select(tb_all, c('Building_Meter', 'Month', 'Imputed_KWH'))
# replace all zero values with NA
tb_all <- na_if(tb_all, 0)
accounts = tb_all %>% group_by(Building_Meter)
accounts <- accounts %>% summarise(counts = n(), na_counts = sum(is.na(Imputed_KWH)))
accounts <- filter(accounts, counts - na_counts >= 50)
accounts <- mutate(accounts, na_perc = na_counts/counts)
accounts
summary(accounts$na_perc)
dim(accounts[accounts$na_counts == 0, ])
head(accounts[accounts$na_counts == 0, ])
# no missing value
account = '165.0 - BLD 03_90327795'
tb =  select(filter(tb_all, Building_Meter == account), 'Month', 'Imputed_KWH')
ggplot(tb, aes(x = Month, y = Imputed_KWH)) + geom_point() + geom_line()
tb =  select(filter(tb_all, Building_Meter == account), 'Month', 'Imputed_KWH')
# no missing value
account = '165.0 - BLD 03_90327795'
# XmR on residual part
ts_anomalized <- tb %>%
time_decompose(value.forecasted, method = "STL", merge = TRUE)
x_Plot <- ggplot(ts_anomalized, aes(x = month, y = remainder)) + geom_point() + geom_line() +
stat_QC(method = 'XmR', auto.label = T, label.digits = 2, show.1n2.sigma = F)
mR_Plot <- ggplot(ts_anomalized, aes(x = month, y = remainder)) + stat_mR() + stat_QC_labels(method="mR")
grid.arrange(x_Plot, mR_Plot, nrow=2)
library(ggQC)
x_Plot <- ggplot(ts_anomalized, aes(x = month, y = remainder)) + geom_point() + geom_line() +
stat_QC(method = 'XmR', auto.label = T, label.digits = 2, show.1n2.sigma = F)
mR_Plot <- ggplot(ts_anomalized, aes(x = month, y = remainder)) + stat_mR() + stat_QC_labels(method="mR")
grid.arrange(x_Plot, mR_Plot, nrow=2)
# XmR on residual part
ts_anomalized <- tb %>%
time_decompose(value.forecasted, method = "STL", merge = TRUE)
tb
# XmR on residual part
ts_anomalized <- tb %>%
time_decompose(Imputed_KWH, method = "STL", merge = TRUE)
x_Plot <- ggplot(ts_anomalized, aes(x = month, y = remainder)) + geom_point() + geom_line() +
stat_QC(method = 'XmR', auto.label = T, label.digits = 2, show.1n2.sigma = F)
mR_Plot <- ggplot(ts_anomalized, aes(x = month, y = remainder)) + stat_mR() + stat_QC_labels(method="mR")
grid.arrange(x_Plot, mR_Plot, nrow=2)
# summarize the control limits
QC_Lines(data = ts_anomalized$remainder, method = "XmR")
x_Plot <- ggplot(tb, aes(x = Month, y = Imputed_KWH)) + geom_point() + geom_line() +
stat_QC(method = 'XmR', auto.label = T, label.digits = 2, show.1n2.sigma = F)
x_Plot
mR_Plot <- ggplot(tb, aes(x = Month, y = Imputed_KWH)) + stat_mR() + stat_QC_labels(method="mR")
mR_Plot
ts_anomalized
x_Plot <- ggplot(ts_anomalized, aes(x = month, y = remainder)) + geom_point() + geom_line() +
stat_QC(method = 'XmR', auto.label = T, label.digits = 2, show.1n2.sigma = F)
x_Plot
x_Plot <- ggplot(ts_anomalized, aes(x = month, y = remainder)) + geom_point() + geom_line() +
stat_QC(method = 'XmR', auto.label = T, label.digits = 2, show.1n2.sigma = F)
mR_Plot <- ggplot(ts_anomalized, aes(x = month, y = remainder)) + stat_mR() + stat_QC_labels(method="mR")
x_Plot <- ggplot(ts_anomalized, aes(x = Month, y = remainder)) + geom_point() + geom_line() +
stat_QC(method = 'XmR', auto.label = T, label.digits = 2, show.1n2.sigma = F)
mR_Plot <- ggplot(ts_anomalized, aes(x = Month, y = remainder)) + stat_mR() + stat_QC_labels(method="mR")
grid.arrange(x_Plot, mR_Plot, nrow=2)
rename(ts_anomalized, Residual = remainder)
x_Plot <- ggplot(ts_anomalized, aes(x = Month, y = remainder)) + geom_point() + geom_line() +
stat_QC(method = 'XmR', auto.label = T, label.digits = 2, show.1n2.sigma = F)
mR_Plot <- ggplot(ts_anomalized, aes(x = Month, y = remainder)) + stat_mR() + stat_QC_labels(method="mR")
grid.arrange(x_Plot, mR_Plot, nrow=2)
# XmR on residual part
ts_anomalized <- tb %>%
time_decompose(Imputed_KWH, method = "STL", merge = TRUE)
ts_anomalized <- rename(ts_anomalized, Residual = remainder)
x_Plot <- ggplot(ts_anomalized, aes(x = Month, y = Residual)) + geom_point() + geom_line() +
stat_QC(method = 'XmR', auto.label = T, label.digits = 2, show.1n2.sigma = F)
mR_Plot <- ggplot(ts_anomalized, aes(x = Month, y = Residual)) + stat_mR() + stat_QC_labels(method="mR")
grid.arrange(x_Plot, mR_Plot, nrow=2)
# summarize the control limits
QC_Lines(data = ts_anomalized$Residual, method = "XmR")
# summarize the control limits
ctrl_limits <- QC_Lines(data = ts_anomalized$Residual, method = "XmR")
ctrl_limits
head(ts_anomalized)
ts_anomalized$Residual < ctrl_limits$xBar_one_LCL
(ts_anomalized$Residual < ctrl_limits$xBar_one_LCL) & (ts_anomalized$Residual > ctrl_limits$xBar_one_UCL)
mask = (ts_anomalized$Residual < ctrl_limits$xBar_one_LCL) & (ts_anomalized$Residual > ctrl_limits$xBar_one_UCL)
mask
ts_anomalized[mask]
ts_anomalized[mask, ]
ts_anomalized[mask]
mask = (ts_anomalized$Residual < ctrl_limits$xBar_one_LCL) | (ts_anomalized$Residual > ctrl_limits$xBar_one_UCL)
ts_anomalized[mask, ]
cbind(ts_anomalized, ctrl_limits)
ts_anomalized <- cbind(ts_anomalized, ctrl_limits)
head(ts_anomalized)
mutate(ts_anomalized, )
cal_devpc <- function(x) {}
if (x$Residual < x$xBar_one_LCL) {
return(x$xBar_one_LCL - x$Residual)
} else if (x$Residual > x$xBar_one_UCL) {
return(x$Residual - x$xBar_one_UCL)
} else {
return (NA)
}
cal_devpc <- function(x) {
if (x$Residual < x$xBar_one_LCL) {
return(x$xBar_one_LCL - x$Residual)
} else if (x$Residual > x$xBar_one_UCL) {
return(x$Residual - x$xBar_one_UCL)
} else {
return (NA)
}
}
mask = (ts_anomalized$Residual < ctrl_limits$xBar_one_LCL) | (ts_anomalized$Residual > ctrl_limits$xBar_one_UCL)
cal_devpc <- function(x) {
if (x$Residual < x$xBar_one_LCL) {
return(x$xBar_one_LCL - x$Residual)
} else if (x$Residual > x$xBar_one_UCL) {
return(x$Residual - x$xBar_one_UCL)
} else {
return (NA)
}
}
cal_dev <- function(x) {
if (x$Residual < x$xBar_one_LCL) {
return(x$xBar_one_LCL - x$Residual)
} else if (x$Residual > x$xBar_one_UCL) {
return(x$Residual - x$xBar_one_UCL)
} else {
return (NA)
}
}
mutate(ts_anomalized, dev = cal_dev(ts_anomalized))
X_data=tibble(v1=c(1,2,3),
v2=c(2,2,2),
v3=c(3,2,1)
)
n <- 100
z0 <- data.frame(A = sample(c("y","n",NA), n, replace = T, prob = c(.4,.4,.1)),
B = sample(c("y","n",NA), n, replace = T, prob = c(.4,.4,.1)),
C = sample(c("y","n",NA), n, replace = T, prob = c(.4,.4,.1)))
zz0
z0
z0 %>%
mutate(new = pmap(., ~any("y" == .x)))
ts_anomalized %>% mutate(dev = pmap(., cal_dev))
ts_anomalized %>% mutate(dev = pmap(., cal_dev()))
map_table=tibble(id=c(1,2,3),
value=c("a", "b", "c")
)
map_table
# the data to get the label
X_data=tibble(v1=c(1,2,3),
v2=c(2,2,2),
v3=c(3,2,1)
)
X_data
tib_res_2=mutate_all(X_data, .funs = get_label)
tib_res_2
get_label <- function(x)
{
res=filter(map_table, id==x)$value
return(res)
}
# the data to get the label
X_data=tibble(v1=c(1,2,3),
v2=c(2,2,2),
v3=c(3,2,1)
)
X_data
tib_res_2=mutate_all(X_data, .funs = get_label)
tib_res_2
mutate_all(ts_anomalized, .funs = cal_dev)
cal_dev <- function(x) {
if (x$Residual < x$xBar_one_LCL) {
return(x$xBar_one_LCL - x$Residual)
} else if (x$Residual > x$xBar_one_UCL) {
return(x$Residual - x$xBar_one_UCL)
} else {
return (NA)
}
}
cal_dev(ts_anomalized[1, ])
cal_dev(ts_anomalized[10, ])
cal_dev(ts_anomalized[36, ])
nrows(ts_anomalized)
nrow(ts_anomalized)
dev <- rep(NA, nrow(ts_anomalized))
dev[i] <- cal_dev(ts_anomalized[i, ])
dev <- rep(NA, nrow(ts_anomalized))
for (i in seq_along(ts_anomalized)) {
dev[i] <- cal_dev(ts_anomalized[i, ])
}
dev
ts_anomalized[i, ]
i = 36
ts_anomalized[i, ]
cal_dev(ts_anomalized[i, ])
dev
dev <- rep(NA, nrow(ts_anomalized))
for (i in seq_along(ts_anomalized)) {
dev[[i]] <- cal_dev(ts_anomalized[i, ])
}
dev
for (i in seq_along(ts_anomalized)) {
cat(i)
}
for (i in 1:seq_along(ts_anomalized)) {
cat(i)
}
for (i in 1:nrow(ts_anomalized)) {
cat(i)
}
dev <- rep(NA, nrow(ts_anomalized))
for (i in 1:nrow(ts_anomalized)) {
dev[[i]] <- cal_dev(ts_anomalized[i, ])
}
dev
ts_anomalized$dev = dev
head(ts_anomalized)
filter(ts_anomalized, !is.na(dev))
order_by(filter(ts_anomalized, !is.na(dev)), dev)
order(filter(ts_anomalized, !is.na(dev)), dev)
order(filter(ts_anomalized, !is.na(dev)), dev, desc)
arrange(filter(ts_anomalized, !is.na(dev)), dev)
arrange(filter(ts_anomalized, !is.na(dev)), dev, asc = FALSE)
arrange(filter(ts_anomalized, !is.na(dev)), dev, asc = false)
arrange(filter(ts_anomalized, !is.na(dev)), dev)
arrange(filter(ts_anomalized, !is.na(dev)), dev)
arrange(filter(ts_anomalized, !is.na(dev)), desc(dev))
select(arrange(filter(ts_anomalized, !is.na(dev)), desc(dev)), c('Month', 'Imputed_KWH', 'trend', 'season', 'Residual', 'dev'))
ts_anomalized$Dev = dev
select(arrange(filter(ts_anomalized, !is.na(dev)), desc(dev)), c('Month', 'Imputed_KWH', 'trend', 'season', 'Residual', 'Dev'))
anomalies <- select(arrange(filter(ts_anomalized, !is.na(dev)), desc(dev)), c('Month', 'Imputed_KWH', 'trend', 'season', 'Residual'))
rename(anomalies, Observed = Imputed_KWH, Trend = trend, Seasonal = season)
dim(accounts)
account = '1.0 - BLD 02_7694040'
# Forecast package, tsclean for imputation & outlier detection
# convert the tibble to time series object
tb <- tb[order(tb$Month), ]
ts.orig <- ts(tb$Imputed_KWH, start = c(year(min(tb$Month)), month(min(tb$Month))),, frequency = 12)
ts.clean <- tsclean(ts.orig)
ts.plot(ts.orig, ts.clean, gpars = list(col = c("red", "blue")))
# define a function to convert ts to dataframe
ts_to_df <- function(ts) {
data.frame(month = as.Date(as.yearmon(time(ts))), value = as.matrix(ts))
}
df.orig <- ts_to_df(ts.orig)
df.clean <- ts_to_df(ts.clean)
df <- cbind(df.orig, df.clean[, 2])
colnames(df) <- c('month', 'value.orig', 'value.forecasted')
df <- mutate(df, value.diff = value.forecasted - value.orig)
filter(df, value.diff != 0)
# better visualization to compare the observed and cleaned
ggplot() +
geom_line(data = df.orig, aes(x = month, y = value), color = "red") +
geom_point(data = df.orig, aes(x = month, y = value), color = "red") +
geom_line(data = df.clean, aes(x = month, y = value), color = "blue") +
geom_point(data = df.clean, aes(x = month, y = value), color = "blue") +
xlab('Month') +
ylab('KWH Consumptions')
account = '1.0 - BLD 02_7694040'
tb =  select(filter(tb_all, Building_Meter == account), 'Month', 'Imputed_KWH')
ggplot(tb, aes(x = Month, y = Imputed_KWH)) + geom_point() + geom_line()
# Forecast package, tsclean for imputation & outlier detection
# convert the tibble to time series object
tb <- tb[order(tb$Month), ]
ts.orig <- ts(tb$Imputed_KWH, start = c(year(min(tb$Month)), month(min(tb$Month))),, frequency = 12)
ts.clean <- tsclean(ts.orig)
ts.plot(ts.orig, ts.clean, gpars = list(col = c("red", "blue")))
# define a function to convert ts to dataframe
ts_to_df <- function(ts) {
data.frame(month = as.Date(as.yearmon(time(ts))), value = as.matrix(ts))
}
df.orig <- ts_to_df(ts.orig)
df.clean <- ts_to_df(ts.clean)
df <- cbind(df.orig, df.clean[, 2])
colnames(df) <- c('month', 'value.orig', 'value.forecasted')
df <- mutate(df, value.diff = value.forecasted - value.orig)
filter(df, value.diff != 0)
# better visualization to compare the observed and cleaned
ggplot() +
geom_line(data = df.orig, aes(x = month, y = value), color = "red") +
geom_point(data = df.orig, aes(x = month, y = value), color = "red") +
geom_line(data = df.clean, aes(x = month, y = value), color = "blue") +
geom_point(data = df.clean, aes(x = month, y = value), color = "blue") +
xlab('Month') +
ylab('KWH Consumptions')
grid.arrange(
ggplot(df.orig, aes(x = month, y = value)) + geom_point() + geom_line()
, ggplot(df.clean, aes(x = month, y = value)) + geom_point() + geom_line()
)
require(graphics)
tb =  select(filter(tb_all, Building_Meter == account), 'Month', 'Imputed_KWH')
ts_anomalized <- tb %>%
time_decompose(Imputed_KWH, method = "STL", merge = TRUE) %>%
anomalize(remainder, method = 'iqr', alpha = 0.05) %>%
time_recompose()
ts_anomalized %>% plot_anomaly_decomposition(alpha_dot = 0.5) +
ggtitle("Observed & Residuals")
tb =  select(filter(tb_all, Building_Meter == account), 'Month', 'Imputed_KWH')
ts_anomalized <- tb %>%
time_decompose(Imputed_KWH, method = "STL", merge = TRUE) %>%
anomalize(remainder, method = 'iqr', alpha = 0.05) %>%
time_recompose()
plot(stl(ts.clean, "per"))
plot(stl(ts.clean, s.window = 12, t.window = 51, t.jump = 1))
ts.stl <- stl(ts.clean, s.window = 13, t.window = 51, t.jump = 1)
ts.stl <- mstl(ts.clean)
ts.orig %>% autoplot()
ts.clean %>% autoplot()
ts.stl1 <- mstl(ts.orig)
ts.stl1 %>% autoplot()
ts.stl2 <- mstl(ts.clean)
ts.stl2 %>% autoplot()
plot(seasonal(ts.stl))
plot(trendcycle(ts.stl))
tb =  select(filter(tb_all, Building_Meter == account), 'Month', 'Imputed_KWH')
tb
is.na(tb$Imputed_KWH)
tb[is.na(tb$Imputed_KWH)]
tb[is.na(tb$Imputed_KWH), ]
tb[is.na(tb$Imputed_KWH), 'Imputed_KWH']
tb[is.na(tb$Imputed_KWH), 'Imputed_KWH'] <- 0
ts_anomalized <- tb %>%
time_decompose(Imputed_KWH, method = "STL", merge = TRUE) %>%
anomalize(remainder, method = 'iqr', alpha = 0.05) %>%
time_recompose()
ts_anomalized %>% plot_anomaly_decomposition(alpha_dot = 0.5) +
ggtitle("Observed & Residuals")
match(min(tb$Imputed_KWH), ts.orig)
ts.orig
